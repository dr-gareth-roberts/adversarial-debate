"""Markdown output formatter for documentation-friendly output."""

from datetime import UTC, datetime
from typing import Any

from .base import Formatter, FormatterConfig, OutputFormat

# Severity emoji indicators
SEVERITY_EMOJI = {
    "CRITICAL": "ðŸ”´",
    "HIGH": "ðŸŸ ",
    "MEDIUM": "ðŸŸ¡",
    "LOW": "ðŸŸ¢",
    "INFO": "ðŸ”µ",
}

# Verdict emoji
VERDICT_EMOJI = {
    "BLOCK": "ðŸš«",
    "WARN": "âš ï¸",
    "PASS": "âœ…",
}


class MarkdownFormatter(Formatter):
    """Markdown output formatter.

    Produces GitHub-flavored Markdown suitable for documentation,
    PR comments, or issue descriptions.
    """

    def __init__(self, config: FormatterConfig | None = None):
        super().__init__(config)

    @property
    def format_type(self) -> OutputFormat:
        return OutputFormat.MARKDOWN

    @property
    def file_extension(self) -> str:
        return ".md"

    @property
    def content_type(self) -> str:
        return "text/markdown"

    def format(self, data: dict[str, Any]) -> str:
        """Format data as Markdown.

        Args:
            data: Analysis results

        Returns:
            Markdown string
        """
        findings = data.get("findings", [])
        verdict = data.get("verdict", {})
        metadata = data.get("metadata", {})

        parts = [
            self._md_header(metadata),
            self._md_summary(findings, verdict),
        ]

        if verdict:
            parts.append(self._md_verdict(verdict))

        if findings:
            parts.append(self._md_findings(findings))

        parts.append(self._md_footer())

        return "\n\n".join(filter(None, parts))

    def _md_header(self, metadata: dict[str, Any]) -> str:
        """Generate Markdown header."""
        timestamp = datetime.now(UTC).strftime("%Y-%m-%d %H:%M:%S UTC")
        return f"""# ðŸ›¡ï¸ Security Analysis Report

> Generated by **{self.config.tool_name}** v{self.config.tool_version}
> {timestamp}"""

    def _md_summary(self, findings: list[dict[str, Any]], verdict: dict[str, Any]) -> str:
        """Generate summary section."""
        # Count by severity
        severity_counts: dict[str, int] = {}
        for finding in findings:
            sev = finding.get("severity", "UNKNOWN")
            severity_counts[sev] = severity_counts.get(sev, 0) + 1

        summary = f"## Summary\n\n**Total Findings:** {len(findings)}\n\n"

        # Severity table
        if findings:
            summary += "| Severity | Count |\n|----------|-------|\n"
            for sev in ["CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO"]:
                count = severity_counts.get(sev, 0)
                if count > 0:
                    emoji = SEVERITY_EMOJI.get(sev, "âšª")
                    summary += f"| {emoji} {sev} | {count} |\n"

        return summary

    def _md_verdict(self, verdict: dict[str, Any]) -> str:
        """Generate verdict section."""
        summary = verdict.get("summary", verdict)
        decision = summary.get("decision", "UNKNOWN")
        emoji = VERDICT_EMOJI.get(decision, "â“")

        md = f"""## Verdict

### {emoji} {decision}
"""

        if summary.get("blocking_issues"):
            md += f"\n- **Blocking Issues:** {summary['blocking_issues']}"
        if summary.get("warnings"):
            md += f"\n- **Warnings:** {summary['warnings']}"
        if summary.get("passed"):
            md += f"\n- **Passed:** {summary['passed']}"
        if summary.get("false_positives"):
            md += f"\n- **False Positives:** {summary['false_positives']}"

        report = summary.get("report") or verdict.get("report")
        if report:
            md += f"\n\n{report}"

        return md

    def _md_findings(self, findings: list[dict[str, Any]]) -> str:
        """Generate findings section."""
        # Sort by severity
        severity_order = {"CRITICAL": 0, "HIGH": 1, "MEDIUM": 2, "LOW": 3, "INFO": 4}
        sorted_findings = sorted(
            findings, key=lambda f: severity_order.get(f.get("severity", "MEDIUM"), 5)
        )

        md = "## Findings\n"

        for i, finding in enumerate(sorted_findings, 1):
            md += "\n" + self._md_finding(finding, i)

        return md

    def _md_finding(self, finding: dict[str, Any], index: int) -> str:
        """Generate Markdown for a single finding."""
        severity = finding.get("severity", "MEDIUM")
        emoji = SEVERITY_EMOJI.get(severity, "âšª")
        title = finding.get("title", f"Finding #{index}")

        md = f"### {emoji} {title}\n\n"

        # Metadata table
        md += "| Property | Value |\n|----------|-------|\n"
        md += f"| Severity | {severity} |\n"

        if finding.get("file_path"):
            location = str(finding["file_path"])
            if finding.get("line"):
                location += f":{finding['line']}"
            md += f"| Location | `{location}` |\n"

        if finding.get("confidence"):
            md += f"| Confidence | {finding['confidence']:.0%} |\n"

        if finding.get("agent"):
            md += f"| Agent | {finding['agent']} |\n"

        if finding.get("cwe"):
            cwe = finding["cwe"]
            md += f"| CWE | [CWE-{cwe}](https://cwe.mitre.org/data/definitions/{cwe}.html) |\n"

        if finding.get("exploitation_difficulty"):
            md += f"| Exploitation | {finding['exploitation_difficulty']} |\n"

        # Description
        description = finding.get("description")
        if description:
            md += f"\n**Description:**\n{description}\n"

        # Code snippet
        code = finding.get("code_snippet") or finding.get("vulnerable_code")
        if code:
            # Try to detect language from file extension
            file_path = finding.get("file_path", "")
            lang = ""
            if file_path.endswith(".py"):
                lang = "python"
            elif file_path.endswith((".js", ".ts", ".jsx", ".tsx")):
                lang = "javascript"
            elif file_path.endswith((".java",)):
                lang = "java"
            elif file_path.endswith((".go",)):
                lang = "go"
            elif file_path.endswith((".rs",)):
                lang = "rust"

            md += f"\n**Vulnerable Code:**\n```{lang}\n{code}\n```\n"

        # Impact
        impact = finding.get("impact")
        if impact:
            md += f"\n**Impact:** {impact}\n"

        # Remediation
        remediation = finding.get("remediation")
        if remediation:
            md += f"\n**ðŸ’¡ Remediation:**\n> {remediation}\n"

        # Attack steps
        attack_steps = finding.get("attack_steps") or finding.get("reproduction_steps")
        if attack_steps:
            md += "\n**Attack Steps:**\n"
            for i, step in enumerate(attack_steps, 1):
                if isinstance(step, str):
                    md += f"{i}. {step}\n"
                else:
                    md += f"{i}. {step.get('description', str(step))}\n"

        md += "\n---\n"
        return md

    def _md_footer(self) -> str:
        """Generate Markdown footer."""
        return f"""---

*Report generated by [{self.config.tool_name}](https://github.com/dr-gareth-roberts/adversarial-debate)*
*v{self.config.tool_version}*
"""
