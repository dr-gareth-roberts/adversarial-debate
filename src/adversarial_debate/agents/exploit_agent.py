"""ExploitAgent - Security-focused adversarial agent for finding vulnerabilities.

This agent systematically probes code for security vulnerabilities based on
OWASP Top 10 categories:
- A01: Broken Access Control
- A02: Cryptographic Failures
- A03: Injection (SQL, Command, XSS, Template, etc.)
- A05: Security Misconfiguration
- A08: Insecure Deserialization
- A10: Server-Side Request Forgery (SSRF)
"""

import json
from typing import Any

from ..providers import Message, ModelTier
from ..store import BeadType
from .base import Agent, AgentContext, AgentOutput

EXPLOIT_AGENT_SYSTEM_PROMPT = """You are a senior penetration tester and security researcher.
Your job is to find EXPLOITABLE security vulnerabilities, not theoretical risks.

## OWASP Top 10 2021 Categories

### A01: Broken Access Control
- Insecure Direct Object Reference (IDOR)
- Missing authentication on sensitive endpoints
- Path traversal
- Privilege escalation
- CORS misconfiguration

### A02: Cryptographic Failures
- Weak hashing (MD5, SHA1 for passwords)
- Hardcoded secrets/keys
- Insecure random number generation
- Missing encryption for sensitive data

### A03: Injection
- SQL injection: ' OR '1'='1, UNION SELECT, blind injection
- Command injection: ; ls, $(whoami), `id`
- XSS: <script>, onerror=, javascript:
- Template injection: {{7*7}}, ${7*7}
- LDAP/XPath injection

### A05: Security Misconfiguration
- Debug mode enabled
- Default credentials
- Overly permissive CORS
- Missing security headers
- Verbose error messages

### A08: Software and Data Integrity Failures
- Insecure deserialization (pickle, yaml.load)
- Unsigned data used for critical decisions

### A10: Server-Side Request Forgery (SSRF)
- User-controlled URLs in server requests
- Access to internal services via URL manipulation

## Output Format

You MUST respond with valid JSON in this exact format:

{
  "target": {
    "file_path": "path/to/file.py",
    "function_name": "function_being_analyzed",
    "exposure": "public"
  },
  "findings": [
    {
      "id": "EXPLOIT-001",
      "title": "SQL Injection in user lookup",
      "severity": "CRITICAL",
      "owasp_category": "A03:2021-Injection",
      "cwe_id": "CWE-89",
      "confidence": 0.8,
      "description": "Detailed description of the vulnerability",
      "vulnerable_code": {
        "file": "path/to/file.py",
        "line_start": 42,
        "line_end": 45,
        "snippet": "cursor.execute('SELECT * FROM users WHERE id=' + user_id)"
      },
      "exploit": {
        "description": "How to exploit this vulnerability",
        "payload": "1' UNION SELECT password FROM users--",
        "curl_command": "curl 'http://target/api/user?id=1%27%20UNION...'",
        "prerequisites": ["Valid session", "Know table structure"],
        "impact": "Full database read access, credential theft"
      },
      "remediation": {
        "immediate": "Use parameterized queries",
        "code_fix": "cursor.execute('SELECT * FROM users WHERE id = ?', (user_id,))",
        "defense_in_depth": ["Add WAF rule", "Implement least-privilege DB user"]
      }
    }
  ],
  "attack_surface_analysis": {
    "user_inputs": ["query parameters", "POST body", "headers"],
    "external_calls": ["database", "external API", "file system"],
    "sensitive_data": ["passwords", "tokens", "PII"]
  },
  "confidence": 0.8,
  "assumptions": ["assumptions made"],
  "unknowns": ["things that couldn't be determined"]
}

Field constraints:
- severity: one of CRITICAL|HIGH|MEDIUM|LOW
- exposure: one of public|authenticated|internal
- confidence: float 0.0-1.0

## Rules

1. Only report vulnerabilities you can PROVE with a working exploit
2. Provide actual payloads that would trigger the vulnerability
3. Assess severity based on:
   - CRITICAL: RCE, full database access, authentication bypass
   - HIGH: Significant data access, privilege escalation
   - MEDIUM: Limited data access, information disclosure
   - LOW: Theoretical issues, requires unlikely conditions
4. Include OWASP category and CWE ID for each finding
5. Provide concrete remediation with code examples
6. Do NOT report:
   - Theoretical issues without concrete exploit
   - Style issues or code smells
   - Performance concerns
   - Missing features
"""


class ExploitAgent(Agent):
    """Security-focused adversarial agent that finds exploitable vulnerabilities.

    This agent:
    1. Analyzes code for security vulnerabilities
    2. Generates working exploit payloads
    3. Maps findings to OWASP Top 10 categories
    4. Provides concrete remediation guidance

    Produces EXPLOIT_ANALYSIS beads with:
    - findings: List of security vulnerabilities with exploits
    - attack_surface_analysis: Analysis of inputs and sensitive data
    - owasp_coverage: Which OWASP categories were checked
    """

    @property
    def name(self) -> str:
        return "ExploitAgent"

    @property
    def bead_type(self) -> BeadType:
        return BeadType.EXPLOIT_ANALYSIS

    @property
    def model_tier(self) -> ModelTier:
        # Security analysis needs strong reasoning
        return ModelTier.HOSTED_LARGE

    def _build_prompt(self, context: AgentContext) -> list[Message]:
        """Build the ExploitAgent prompt with target code and security context."""
        target_code = context.inputs.get("code", "")
        file_path = context.inputs.get("file_path", "unknown")
        function_name = context.inputs.get("function_name", "")
        language = context.inputs.get("language", "python")

        # Security-specific context
        exposure = context.inputs.get("exposure", "internal")
        data_sensitivity = context.inputs.get("data_sensitivity", "unknown")
        framework = context.inputs.get("framework", "")
        security_context = context.inputs.get("security_context", {})

        # Related code for context
        related_code = context.inputs.get("related_code", "")

        # Build user message
        user_message_parts = [
            "## Target Code",
            "",
            f"**File:** `{file_path}`",
        ]

        if function_name:
            user_message_parts.append(f"**Function/Class:** `{function_name}`")

        user_message_parts.extend(
            [
                f"**Language:** {language}",
                f"**Exposure:** {exposure}",
                "",
                f"```{language}",
                target_code,
                "```",
                "",
            ]
        )

        # Add security context
        user_message_parts.append("## Security Context")
        user_message_parts.append("")
        user_message_parts.append(f"- **Exposure Level:** {exposure}")
        user_message_parts.append(f"- **Data Sensitivity:** {data_sensitivity}")

        if framework:
            user_message_parts.append(f"- **Framework:** {framework}")

        if security_context:
            if security_context.get("has_auth"):
                user_message_parts.append("- **Authentication:** Present")
            if security_context.get("handles_user_input"):
                user_message_parts.append("- **User Input:** Yes (check injection)")
            if security_context.get("makes_external_requests"):
                user_message_parts.append("- **External Requests:** Yes (check SSRF)")
            if security_context.get("handles_files"):
                user_message_parts.append("- **File Operations:** Yes (check path traversal)")
            if security_context.get("uses_crypto"):
                user_message_parts.append("- **Cryptography:** Yes (check weak algorithms)")
            if security_context.get("uses_serialization"):
                user_message_parts.append("- **Serialization:** Yes (check insecure deserialize)")

        user_message_parts.append("")

        # Add related code if provided
        if related_code:
            user_message_parts.extend(
                [
                    "## Related Code (for context)",
                    "",
                    f"```{language}",
                    related_code,
                    "```",
                    "",
                ]
            )

        # Final instructions
        user_message_parts.extend(
            [
                "## Your Mission",
                "",
                "Find exploitable security vulnerabilities in this code.",
                "",
                "For each vulnerability:",
                "1. Identify the OWASP category and CWE ID",
                "2. Provide a working exploit payload",
                "3. Explain the impact if exploited",
                "4. Provide code to fix the vulnerability",
                "",
                "Focus on:",
                "- Injection (SQL, command, XSS, template)",
                "- Broken access control (IDOR, missing auth, path traversal)",
                "- Cryptographic failures (weak hashing, hardcoded secrets)",
                "- Security misconfiguration (debug mode, CORS)",
                "- Insecure deserialization (pickle, yaml)",
                "- SSRF (user-controlled URLs)",
                "",
                "Do NOT report:",
                "- Theoretical vulnerabilities without concrete exploit",
                "- Code style issues",
                "- Performance concerns",
                "",
                "Respond with valid JSON matching the schema in your instructions.",
            ]
        )

        return [
            Message(role="system", content=EXPLOIT_AGENT_SYSTEM_PROMPT),
            Message(role="user", content="\n".join(user_message_parts)),
        ]

    def _parse_response(
        self,
        response: str,
        context: AgentContext,
    ) -> AgentOutput:
        """Parse ExploitAgent response into structured findings."""
        try:
            data = self._parse_json_response(response)
        except json.JSONDecodeError as e:
            return AgentOutput(
                agent_name=self.name,
                result={
                    "findings": [],
                    "error": f"Failed to parse response: {e}",
                },
                beads_out=[],
                confidence=0.0,
                errors=[f"Failed to parse response as JSON: {e}"],
            )

        findings = data.get("findings", [])
        target = data.get("target", {})
        attack_surface = data.get("attack_surface_analysis", {})

        # Validate and normalize findings
        normalized_findings = []
        for i, finding in enumerate(findings):
            normalized = self._normalize_finding(finding, i, context)
            if normalized:
                normalized_findings.append(normalized)

        # Count by OWASP category
        owasp_counts: dict[str, int] = {}
        for f in normalized_findings:
            cat = f.get("owasp_category", "Unknown")
            owasp_counts[cat] = owasp_counts.get(cat, 0) + 1

        # Create the bead payload
        payload = {
            "target": target,
            "findings_count": len(normalized_findings),
            "findings_by_severity": self._count_by_severity(normalized_findings),
            "findings_by_owasp": owasp_counts,
            "has_critical": any(f.get("severity") == "CRITICAL" for f in normalized_findings),
            "has_high": any(f.get("severity") == "HIGH" for f in normalized_findings),
            "attack_surface": attack_surface,
        }

        bead = self._create_bead(
            context,
            payload=payload,
            artefacts=[],
            confidence=data.get("confidence", 0.8),
            assumptions=data.get("assumptions", []),
            unknowns=data.get("unknowns", []),
        )

        return AgentOutput(
            agent_name=self.name,
            result={
                "target": target,
                "findings": normalized_findings,
                "attack_surface_analysis": attack_surface,
                "summary": {
                    "total_findings": len(normalized_findings),
                    "by_severity": self._count_by_severity(normalized_findings),
                    "by_owasp": owasp_counts,
                },
            },
            beads_out=[bead],
            confidence=data.get("confidence", 0.8),
            assumptions=data.get("assumptions", []),
            unknowns=data.get("unknowns", []),
        )

    def _normalize_finding(
        self,
        finding: dict[str, Any],
        index: int,
        context: AgentContext,
    ) -> dict[str, Any] | None:
        """Normalize and validate a security finding."""
        if not finding.get("title"):
            return None

        exploit = finding.get("exploit", {})
        payload = exploit.get("payload") or exploit.get("curl_command")
        if not payload:
            return None

        finding_id = finding.get("id", f"EXPLOIT-{index + 1:03d}")

        severity = finding.get("severity", "MEDIUM").upper()
        if severity not in ("CRITICAL", "HIGH", "MEDIUM", "LOW"):
            severity = "MEDIUM"

        return {
            "id": finding_id,
            "title": finding.get("title", ""),
            "severity": severity,
            "owasp_category": finding.get("owasp_category", "Unknown"),
            "cwe_id": finding.get("cwe_id", ""),
            "confidence": finding.get("confidence", 0.8),
            "description": finding.get("description", ""),
            "vulnerable_code": finding.get("vulnerable_code", {}),
            "exploit": exploit,
            "remediation": finding.get("remediation", {}),
            "file_path": context.inputs.get("file_path", ""),
            "agent": self.name,
            "thread_id": context.thread_id,
            "task_id": context.task_id,
        }

    def _count_by_severity(self, findings: list[dict[str, Any]]) -> dict[str, int]:
        """Count findings by severity."""
        counts = {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0}
        for f in findings:
            severity = f.get("severity", "MEDIUM")
            if severity in counts:
                counts[severity] += 1
        return counts

    def _generate_idempotency_key(self, context: AgentContext) -> str:
        """Generate idempotency key for exploit analysis."""
        file_path = context.inputs.get("file_path", "unknown")
        return f"IK-exploit-{context.thread_id}-{context.task_id}-{file_path.replace('/', '_')}"
